/* eslint-disable no-undef */
/* eslint-disable no-prototype-builtins */
/* eslint-disable no-new-object */
/* eslint-disable no-mixed-operators */
/* eslint-disable new-cap */
/* eslint-disable no-cond-assign */
/* eslint-disable no-void */
/* eslint-disable no-throw-literal */
/* eslint-disable no-return-assign */
/* eslint-disable no-var */
/* eslint-disable eqeqeq */
/* eslint-disable no-sequences */
/* eslint-disable no-unused-expressions */
/* Copyrights for code authored by Yahoo Inc. is licensed under the following terms:
MIT License
Copyright  2017 Yahoo Inc.
Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
!(function (e, t, r, i) { 'use strict'; function n () { return C.isValid() } function o () { return C.isValid() } function a () { const e = { getUserMedia: !0 }; return C.isValid(e) } function s (e) { let t = !1; if (w.isArray(e) && e.length) { if (w.each(e, function (e, r) { w.isSupported.videoCodecs[r] && (t = !0) }), !t) return !1 } else if (w.isString(e) && e.length && !w.isSupported.videoCodecs[e]) return !1; return C.isValid({ getUserMedia: !0 }) } function d () { function e (e, t, r) { let i, n; for (u = e, m = t, g = r, f = new Array(h), i = 0; h > i; i++)f[i] = new Array(4), n = f[i], n[0] = n[1] = n[2] = (i << k + 8) / h | 0, D[i] = F / h | 0, G[i] = 0 } function t () { for (var e = [], t = new Array(h), r = 0; h > r; r++)t[f[r][3]] = r; for (let i = 0, n = 0; h > n; n++) { const o = t[n]; e[i++] = f[o][0], e[i++] = f[o][1], e[i++] = f[o][2] } return e } function r () { let e, t, r, i, n, o, a, s; for (a = 0, s = 0, e = 0; h > e; e++) { for (n = f[e], r = e, i = n[1], t = e + 1; h > t; t++)o = f[t], o[1] < i && (r = t, i = o[1]); if (o = f[r], e != r && (t = o[0], o[0] = n[0], n[0] = t, t = o[1], o[1] = n[1], n[1] = t, t = o[2], o[2] = n[2], n[2] = t, t = o[3], o[3] = n[3], n[3] = t), i != a) { for (P[a] = s + e >> 1, t = a + 1; i > t; t++)P[t] = e; a = i, s = e } } for (P[a] = s + C >> 1, t = a + 1; t < 256; t++)P[t] = C } function i () { let e, t, r, i, n, o, a, f, h, C, x, F, W, O; for (y > m && (g = 1), l = 30 + (g - 1) / 3, F = u, W = 0, O = m, x = m / (3 * g), C = x / S | 0, f = V, o = T, a = o >> U, a <= 1 && (a = 0), e = 0; a > e; e++)N[e] = f * ((a * a - e * e) * z / (a * a)); for (h = y > m ? 3 : m % p !== 0 ? 3 * p : m % v !== 0 ? 3 * v : m % b !== 0 ? 3 * b : 3 * w, e = 0; x > e;) if (r = (255 & F[W + 0]) << k, i = (255 & F[W + 1]) << k, n = (255 & F[W + 2]) << k, t = c(r, i, n), d(f, t, r, i, n), a !== 0 && s(a, t, r, i, n), W += h, W >= O && (W -= m), e++, C === 0 && (C = 1), e % C === 0) for (f -= f / l, o -= o / I, a = o >> U, a <= 1 && (a = 0), t = 0; a > t; t++)N[t] = f * ((a * a - t * t) * z / (a * a)) } function n (e, t, r) { let i, n, o, a, s, d, c; for (s = 1e3, c = -1, i = P[t], n = i - 1; h > i || n >= 0;)h > i && (d = f[i], o = d[1] - t, o >= s ? i = h : (i++, o < 0 && (o = -o), a = d[0] - e, a < 0 && (a = -a), o += a, s > o && (a = d[2] - r, a < 0 && (a = -a), o += a, s > o && (s = o, c = d[3])))), n >= 0 && (d = f[n], o = t - d[1], o >= s ? n = -1 : (n--, o < 0 && (o = -o), a = d[0] - e, a < 0 && (a = -a), o += a, s > o && (a = d[2] - r, a < 0 && (a = -a), o += a, s > o && (s = o, c = d[3])))); return c } function o () { return i(), a(), r(), t() } function a () { let e; for (e = 0; h > e; e++)f[e][0] >>= k, f[e][1] >>= k, f[e][2] >>= k, f[e][3] = e } function s (e, t, r, i, n) { let o, a, s, d, c, l, u; for (s = t - e, s < -1 && (s = -1), d = t + e, d > h && (d = h), o = t + 1, a = t - 1, l = 1; d > o || a > s;) { if (c = N[l++], d > o) { u = f[o++]; try { u[0] -= c * (u[0] - r) / B | 0, u[1] -= c * (u[1] - i) / B | 0, u[2] -= c * (u[2] - n) / B | 0 } catch (m) {} } if (a > s) { u = f[a--]; try { u[0] -= c * (u[0] - r) / B | 0, u[1] -= c * (u[1] - i) / B | 0, u[2] -= c * (u[2] - n) / B | 0 } catch (m) {} } } } function d (e, t, r, i, n) { const o = f[t]; const a = e / V; o[0] -= a * (o[0] - r) | 0, o[1] -= a * (o[1] - i) | 0, o[2] -= a * (o[2] - n) | 0 } function c (e, t, r) { let i, n, o, a, s, d, c, l, u, m; for (l = ~(1 << 31), u = l, d = -1, c = d, i = 0; h > i; i++)m = f[i], n = m[0] - e, n < 0 && (n = -n), o = m[1] - t, o < 0 && (o = -o), n += o, o = m[2] - r, o < 0 && (o = -o), n += o, l > n && (l = n, d = i), a = n - (G[i] >> x - k), u > a && (u = a, c = i), s = D[i] >> O, D[i] -= s, G[i] += s << W; return D[d] += E, G[d] -= M, c } let l; let u; let m; let g; let f; var h = 256; var p = 499; var v = 491; var b = 487; var w = 503; var y = 3 * w; var C = h - 1; var k = 4; var S = 100; var x = 16; var F = 1 << x; var W = 10; var O = 10; var E = F >> O; var M = F << W - O; const A = h >> 3; var U = 6; const R = 1 << U; var T = A * R; var I = 30; const j = 10; var V = 1 << j; const H = 8; var z = 1 << H; const L = j + H; var B = 1 << L; var P = []; var G = []; var D = []; var N = []; e.apply(this, arguments); const q = {}; return q.map = n, q.process = o, q } function c () { const e = this; try { e.onmessage = function (e) { let t; const i = e.data || {}; i.gifshot && (t = r.run(i), postMessage(t)) } } catch (t) {} var r = { dataToRGB: function (e, t, r) { for (var i = t * r * 4, n = 0, o = []; i > n;)o.push(e[n++]), o.push(e[n++]), o.push(e[n++]), n++; return o }, componentizedPaletteToArray: function (e) { e = e || []; for (var t = [], r = 0; r < e.length; r += 3) { const i = e[r]; const n = e[r + 1]; const o = e[r + 2]; t.push(i << 16 | n << 8 | o) } return t }, processFrameWithQuantizer: function (e, t, r, i) { for (var n = this.dataToRGB(e, t, r), o = new d(n, n.length, i), a = o.process(), s = new Uint32Array(this.componentizedPaletteToArray(a)), c = t * r, l = new Uint8Array(c), u = 0, m = 0; c > m; m++) { const g = n[u++]; const f = n[u++]; const h = n[u++]; l[m] = o.map(g, f, h) } return { pixels: l, palette: s } }, run: function (e) { e = e || {}; const t = e; const r = t.height; const i = (t.palette, t.sampleInterval); const n = t.width; const o = e.data; return this.processFrameWithQuantizer(o, n, r, i) } }; return r } function l (e, t, r, n) { function o (e) { const t = e.length; if (t < 2 || t > 256 || t & t - 1) throw 'Invalid code/color length, must be power of 2 and 2 .. 256.'; return t } function a (e, t, r, n) { function o (r) { for (;g >= r;)e[t++] = 255 & f, f >>= 8, g -= 8, t === s + 256 && (e[s] = 255, s = t++) } function a (e) { f |= e << g, g += m, o(8) }e[t++] = r; var s = t++; const d = 1 << r; const c = d - 1; const l = d + 1; let u = l + 1; var m = r + 1; var g = 0; var f = 0; let h = n[0] & c; let p = {}; a(d); for (let v = 1, b = n.length; b > v; ++v) { const w = n[v] & c; const y = h << 8 | w; const C = p[y]; if (C === i) { for (f |= h << g, g += m; g >= 8;)e[t++] = 255 & f, f >>= 8, g -= 8, t === s + 256 && (e[s] = 255, s = t++); u === 4096 ? (a(d), u = l + 1, m = r + 1, p = {}) : (u >= 1 << m && ++m, p[y] = u++), h = w } else h = C } return a(h), a(l), o(1), s + 1 === t ? e[s] = 0 : (e[s] = t - s - 1, e[t++] = 0), t } let s = 0; n = n === i ? {} : n; const d = n.loop === i ? null : n.loop; const c = n.palette === i ? null : n.palette; if (t <= 0 || r <= 0 || t > 65535 || r > 65535) throw 'Width/Height invalid.'; e[s++] = 71, e[s++] = 73, e[s++] = 70, e[s++] = 56, e[s++] = 57, e[s++] = 97; const l = 0; const u = 0; if (e[s++] = 255 & t, e[s++] = t >> 8 & 255, e[s++] = 255 & r, e[s++] = r >> 8 & 255, e[s++] = (c !== null ? 128 : 0) | l, e[s++] = u, e[s++] = 0, d !== null) { if (d < 0 || d > 65535) throw 'Loop count invalid.'; e[s++] = 33, e[s++] = 255, e[s++] = 11, e[s++] = 78, e[s++] = 69, e[s++] = 84, e[s++] = 83, e[s++] = 67, e[s++] = 65, e[s++] = 80, e[s++] = 69, e[s++] = 50, e[s++] = 46, e[s++] = 48, e[s++] = 3, e[s++] = 1, e[s++] = 255 & d, e[s++] = d >> 8 & 255, e[s++] = 0 } let m = !1; this.addFrame = function (t, r, n, d, l, u) { if (m === !0 && (--s, m = !1), u = u === i ? {} : u, t < 0 || r < 0 || t > 65535 || r > 65535) throw 'x/y invalid.'; if (n <= 0 || d <= 0 || n > 65535 || d > 65535) throw 'Width/Height invalid.'; if (l.length < n * d) throw 'Not enough pixels for the frame size.'; let g = !0; let f = u.palette; if ((f === i || f === null) && (g = !1, f = c), f === i || f === null) throw 'Must supply either a local or global palette.'; for (var h = o(f), p = 0; h >>= 1;)++p; h = 1 << p; const v = u.delay === i ? 0 : u.delay; const b = u.disposal === i ? 0 : u.disposal; if (b < 0 || b > 3) throw 'Disposal out of range.'; let w = !1; let y = 0; if (u.transparent !== i && u.transparent !== null && (w = !0, y = u.transparent, y < 0 || y >= h)) throw 'Transparent color index.'; if ((b !== 0 || w || v !== 0) && (e[s++] = 33, e[s++] = 249, e[s++] = 4, e[s++] = b << 2 | (w === !0 ? 1 : 0), e[s++] = 255 & v, e[s++] = v >> 8 & 255, e[s++] = y, e[s++] = 0), e[s++] = 44, e[s++] = 255 & t, e[s++] = t >> 8 & 255, e[s++] = 255 & r, e[s++] = r >> 8 & 255, e[s++] = 255 & n, e[s++] = n >> 8 & 255, e[s++] = 255 & d, e[s++] = d >> 8 & 255, e[s++] = g === !0 ? 128 | p - 1 : 0, g === !0) for (let C = 0, k = f.length; k > C; ++C) { const S = f[C]; e[s++] = S >> 16 & 255, e[s++] = S >> 8 & 255, e[s++] = 255 & S }s = a(e, s, p < 2 ? 2 : p, l) }, this.end = function () { return m === !1 && (e[s++] = 59, m = !0), s } } function u (e, t) { e.getBase64GIF(function (e) { t({ error: !1, errorCode: '', errorMsg: '', image: e }) }) } function m () { function e () { w.each(l, function (e, t) { t && (t.text ? f.addFrame(t.img, a, t.text) : f.addFrame(t, a)) }), u(f, n) } const r = arguments.length > 0 && arguments[0] !== i ? arguments[0] : {}; var n = r.callback; const o = r.images; var a = r.options; let s = r.imagesLength; const d = { getUserMedia: !0, 'window.URL': !0 }; const c = C.validate(d); var l = []; let m = 0; let g = void 0; var f = void 0; return c.error ? n(c) : (f = new O(a), w.each(o, function (r, i) { let o = i; i.src && (o = o.src), w.isElement(o) ? (a.crossOrigin && (o.crossOrigin = a.crossOrigin), l[r] = o, m += 1, m === s && e()) : w.isString(o) && (g = new Image(), a.crossOrigin && (g.crossOrigin = a.crossOrigin), (function (t) { i.text && (t.text = i.text), t.onerror = function () { let e = void 0; return --s, s === 0 ? (e = {}, e.error = 'None of the requested images was capable of being retrieved', n(e)) : void 0 }, t.onload = function () { l[r] = i.text ? { img: t, text: t.text } : t, m += 1, m === s && e(), w.removeElement(t) }, t.src = o }(g)), w.setCSSAttr(g, { position: 'fixed', opacity: '0' }), t.body.appendChild(g)) }), void 0) } function g (e) { e = w.isObject(e) ? e : {}, A.stopVideoStreaming(e) } function f (e, r) { const i = e.options || {}; const n = i.images; const o = i.video; const a = Number(i.gifWidth); const s = Number(i.gifHeight); const d = (Number(i.numFrames), e.cameraStream); const c = e.videoElement; const l = e.videoWidth; const u = e.videoHeight; const m = M.getCropDimensions({ videoWidth: l, videoHeight: u, gifHeight: s, gifWidth: a }); const f = r; i.crop = m, i.videoElement = c, i.videoWidth = l, i.videoHeight = u, i.cameraStream = d, w.isElement(c) && (c.width = a + m.width, c.height = s + m.height, i.webcamVideoElement || (w.setCSSAttr(c, { position: 'fixed', opacity: '0' }), t.body.appendChild(c)), c.play(), M.getGIF(i, function (e) { n && n.length || o && o.length || g(e), f(e) })) } function h () { const e = arguments.length > 0 && arguments[0] !== i ? arguments[0] : {}; const t = e.callback; let r = e.existingVideo; const n = e.options; const o = { getUserMedia: !0, 'window.URL': !0 }; const a = C.validate(o); let s = void 0; let d = void 0; if (a.error) return t(a); if (w.isElement(r) && r.src) { if (d = r.src, s = w.getExtension(d), !w.isSupported.videoCodecs[s]) return t(C.messages.videoCodecs) } else w.isArray(r) && w.each(r, function (e, t) { return s = t instanceof Blob ? t.type.substr(t.type.lastIndexOf('/') + 1, t.length) : t.substr(t.lastIndexOf('.') + 1, t.length), w.isSupported.videoCodecs[s] ? (r = t, !1) : void 0 }); A.startStreaming({ completed: function (e) { e.options = n || {}, f(e, t) }, existingVideo: r, crossOrigin: n.crossOrigin, options: n }) } function p () { const e = arguments.length > 0 && arguments[0] !== i ? arguments[0] : {}; const t = e.callback; const r = e.lastCameraStream; const n = e.options; const a = e.webcamVideoElement; return o() ? n.savedRenderingContexts.length ? (M.getGIF(n, function (e) { t(e) }), void 0) : (A.startVideoStreaming(function () { const e = arguments.length > 0 && arguments[0] !== i ? arguments[0] : {}; e.options = n || {}, f(e, t) }, { lastCameraStream: r, callback: t, webcamVideoElement: a, crossOrigin: n.crossOrigin }), void 0) : t(C.validate()) } function v (e, t) { if (t = w.isFunction(e) ? e : t, e = w.isObject(e) ? e : {}, w.isFunction(t)) { let r = w.mergeOptions(x, e) || {}; const i = e.cameraStream; const n = r.images; const o = n ? n.length : 0; const a = r.video; const s = r.webcamVideoElement; r = w.mergeOptions(r, { gifWidth: Math.floor(r.gifWidth), gifHeight: Math.floor(r.gifHeight) }), o ? m({ images: n, imagesLength: o, callback: t, options: r }) : a ? h({ existingVideo: a, callback: t, options: r }) : p({ lastCameraStream: i, callback: t, webcamVideoElement: s, options: r }) } } function b (e, t) { if (t = w.isFunction(e) ? e : t, e = w.isObject(e) ? e : {}, w.isFunction(t)) { const r = w.mergeOptions(x, e); const i = w.mergeOptions(r, { interval: 0.1, numFrames: 1, gifWidth: Math.floor(r.gifWidth), gifHeight: Math.floor(r.gifHeight) }); v(i, t) } } var w = { URL: e.URL || e.webkitURL || e.mozURL || e.msURL, getUserMedia: (function () { const e = r.getUserMedia || r.webkitGetUserMedia || r.mozGetUserMedia || r.msGetUserMedia; return e ? e.bind(r) : e }()), requestAnimFrame: e.requestAnimationFrame || e.webkitRequestAnimationFrame || e.mozRequestAnimationFrame || e.oRequestAnimationFrame || e.msRequestAnimationFrame, requestTimeout: function (e, t) { if (e = e || w.noop, t = t || 0, !w.requestAnimFrame) return setTimeout(e, t); const r = (new Date()).getTime(); const i = new Object(); const n = w.requestAnimFrame; const o = function a () { const o = (new Date()).getTime(); const s = o - r; s >= t ? e.call() : i.value = n(a) }; return i.value = n(o), i }, Blob: e.Blob || e.BlobBuilder || e.WebKitBlobBuilder || e.MozBlobBuilder || e.MSBlobBuilder, btoa: (function () { const t = e.btoa || function (e) { for (var t = '', r = 0, i = e.length, n = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=', o = void 0, a = void 0, s = void 0, d = void 0, c = void 0, l = void 0, u = void 0; i > r;)o = e.charCodeAt(r++), a = e.charCodeAt(r++), s = e.charCodeAt(r++), d = o >> 2, c = (3 & o) << 4 | a >> 4, l = (15 & a) << 2 | s >> 6, u = 63 & s, isNaN(a) ? l = u = 64 : isNaN(s) && (u = 64), t = t + n.charAt(d) + n.charAt(c) + n.charAt(l) + n.charAt(u); return t }; return t ? t.bind(e) : w.noop }()), isObject: function (e) { return e && Object.prototype.toString.call(e) === '[object Object]' }, isEmptyObject: function (e) { return w.isObject(e) && !Object.keys(e).length }, isArray: function (e) { return e && Array.isArray(e) }, isFunction: function (e) { return e && typeof e === 'function' }, isElement: function (e) { return e && e.nodeType === 1 }, isString: function (e) { return typeof e === 'string' || Object.prototype.toString.call(e) === '[object String]' }, isSupported: { canvas: function () { const e = t.createElement('canvas'); return e && e.getContext && e.getContext('2d') }, webworkers: function () { return e.Worker }, blob: function () { return w.Blob }, Uint8Array: function () { return e.Uint8Array }, Uint32Array: function () { return e.Uint32Array }, videoCodecs: (function () { const e = t.createElement('video'); const r = { mp4: !1, h264: !1, ogv: !1, ogg: !1, webm: !1 }; try { e && e.canPlayType && (r.mp4 = e.canPlayType('video/mp4; codecs="mp4v.20.8"') !== '', r.h264 = (e.canPlayType('video/mp4; codecs="avc1.42E01E"') || e.canPlayType('video/mp4; codecs="avc1.42E01E, mp4a.40.2"')) !== '', r.ogv = e.canPlayType('video/ogg; codecs="theora"') !== '', r.ogg = e.canPlayType('video/ogg; codecs="theora"') !== '', r.webm = e.canPlayType('video/webm; codecs="vp8, vorbis"') !== -1) } catch (i) {} return r }()) }, noop: function () {}, each: function (e, t) { let r = void 0; let i = void 0; if (w.isArray(e)) for (r = -1, i = e.length; ++r < i && t(r, e[r]) !== !1;);else if (w.isObject(e)) for (r in e) if (e.hasOwnProperty(r) && t(r, e[r]) === !1) break }, mergeOptions: function (e, t) { if (w.isObject(e) && w.isObject(t) && Object.keys) { const r = {}; return w.each(e, function (t) { r[t] = e[t] }), w.each(t, function (i) { const n = t[i]; r[i] = w.isObject(n) ? e[i] ? w.mergeOptions(e[i], n) : n : n }), r } }, setCSSAttr: function (e, t, r) { w.isElement(e) && (w.isString(t) && w.isString(r) ? e.style[t] = r : w.isObject(t) && w.each(t, function (t, r) { e.style[t] = r })) }, removeElement: function (e) { w.isElement(e) && e.parentNode && e.parentNode.removeChild(e) }, createWebWorker: function (e) { if (!w.isString(e)) return {}; try { const t = new w.Blob([e], { type: 'text/javascript' }); const r = w.URL.createObjectURL(t); const i = new Worker(r); return { objectUrl: r, worker: i } } catch (n) { return '' + n } }, getExtension: function (e) { return e.substr(e.lastIndexOf('.') + 1, e.length) }, getFontSize: function () { const e = arguments.length > 0 && arguments[0] !== i ? arguments[0] : {}; if (!t.body || e.resizeFont === !1) return e.fontSize; const r = e.text; const n = e.gifWidth; let o = parseInt(e.fontSize, 10); const a = parseInt(e.minFontSize, 10); const s = t.createElement('div'); const d = t.createElement('span'); for (s.setAttribute('width', n), s.appendChild(d), d.innerHTML = r, d.style.fontSize = o + 'px', d.style.textIndent = '-9999px', d.style.visibility = 'hidden', t.body.appendChild(d); d.offsetWidth > n && o >= a;)d.style.fontSize = --o + 'px'; return t.body.removeChild(d), o + 'px' }, webWorkerError: !1 }; const y = Object.freeze({ default: w }); var C = { validate: function (e) { e = w.isObject(e) ? e : {}; let t = {}; return w.each(C.validators, function (r, i) { const n = i.errorCode; return e[n] || i.condition ? void 0 : (t = i, t.error = !0, !1) }), delete t.condition, t }, isValid: function R (e) { const t = C.validate(e); const R = t.error !== !0 ? !0 : !1; return R }, validators: [{ condition: w.isFunction(w.getUserMedia), errorCode: 'getUserMedia', errorMsg: 'The getUserMedia API is not supported in your browser' }, { condition: w.isSupported.canvas(), errorCode: 'canvas', errorMsg: 'Canvas elements are not supported in your browser' }, { condition: w.isSupported.webworkers(), errorCode: 'webworkers', errorMsg: 'The Web Workers API is not supported in your browser' }, { condition: w.isFunction(w.URL), errorCode: 'window.URL', errorMsg: 'The window.URL API is not supported in your browser' }, { condition: w.isSupported.blob(), errorCode: 'window.Blob', errorMsg: 'The window.Blob File API is not supported in your browser' }, { condition: w.isSupported.Uint8Array(), errorCode: 'window.Uint8Array', errorMsg: 'The window.Uint8Array function constructor is not supported in your browser' }, { condition: w.isSupported.Uint32Array(), errorCode: 'window.Uint32Array', errorMsg: 'The window.Uint32Array function constructor is not supported in your browser' }], messages: { videoCodecs: { errorCode: 'videocodec', errorMsg: 'The video codec you are trying to use is not supported in your browser' } } }; const k = Object.freeze({ default: C }); const S = function () {}; var x = { sampleInterval: 10, numWorkers: 2, filter: '', gifWidth: 200, gifHeight: 200, interval: 0.1, numFrames: 10, frameDuration: 1, keepCameraOn: !1, images: [], video: null, webcamVideoElement: null, cameraStream: null, text: '', fontWeight: 'normal', fontSize: '16px', minFontSize: '10px', resizeFont: !1, fontFamily: 'sans-serif', fontColor: '#ffffff', textAlign: 'center', textBaseline: 'bottom', textXCoordinate: null, textYCoordinate: null, progressCallback: S, completeCallback: S, saveRenderingContexts: !1, savedRenderingContexts: [], showFrameText: !0, crossOrigin: 'Anonymous', waterMark: null, waterMarkHeight: null, waterMarkWidth: null, waterMarkXCoordinate: 1, waterMarkYCoordinate: 1 }; const F = Object.freeze({ default: x }); const W = function () {}; var O = function (e) { this.canvas = null, this.ctx = null, this.repeat = 0, this.frames = [], this.numRenderedFrames = 0, this.onRenderCompleteCallback = W, this.onRenderProgressCallback = W, this.workers = [], this.availableWorkers = [], this.generatingGIF = !1, this.options = e, this.initializeWebWorkers(e) }; O.prototype = { workerMethods: c(), initializeWebWorkers: function (e) { const r = this; const i = d.toString() + '(' + c.toString() + '());'; let n = void 0; let o = void 0; let a = void 0; let s = void 0; let l = -1; let u = ''; for (s = e.numWorkers; ++l < s;)n = w.createWebWorker(i), w.isObject(n) ? (o = n.objectUrl, a = n.worker, r.workers.push({ worker: a, objectUrl: o }), r.availableWorkers.push(a)) : (u = n, w.webWorkerError = !!n); this.workerError = u, this.canvas = t.createElement('canvas'), this.canvas.width = e.gifWidth, this.canvas.height = e.gifHeight, this.ctx = this.canvas.getContext('2d'), this.frames = [] }, getWorker: function () { return this.availableWorkers.pop() }, freeWorker: function (e) { this.availableWorkers.push(e) }, byteMap: (function () { for (var e = [], t = 0; t < 256; t++)e[t] = String.fromCharCode(t); return e }()), bufferToString: function (e) { for (var t = e.length, r = '', i = -1; ++i < t;)r += this.byteMap[e[i]]; return r }, onFrameFinished: function (e) { const t = this; const r = t.frames; const i = t.options; const n = !!(i.images || []).length; const o = r.every(function (e) { return !e.beingProcessed && e.done }); t.numRenderedFrames++, n && e(t.numRenderedFrames / r.length), t.onRenderProgressCallback(0.75 * t.numRenderedFrames / r.length), o ? t.generatingGIF || t.generateGIF(r, t.onRenderCompleteCallback) : w.requestTimeout(function () { t.processNextFrame() }, 1) }, processFrame: function (e) { const t = this; const r = (this.options, this.options); const n = r.progressCallback; const o = r.sampleInterval; const a = this.frames; let s = void 0; let d = void 0; const c = function () { const e = arguments.length > 0 && arguments[0] !== i ? arguments[0] : {}; const r = e.data; delete s.data, s.pixels = Array.prototype.slice.call(r.pixels), s.palette = Array.prototype.slice.call(r.palette), s.done = !0, s.beingProcessed = !1, t.freeWorker(d), t.onFrameFinished(n) }; return s = a[e], s.beingProcessed || s.done ? (this.onFrameFinished(), void 0) : (s.sampleInterval = o, s.beingProcessed = !0, s.gifshot = !0, d = this.getWorker(), d ? (d.onmessage = c, d.postMessage(s)) : c({ data: t.workerMethods.run(s) }), void 0) }, startRendering: function (e) { this.onRenderCompleteCallback = e; for (let t = 0; t < this.options.numWorkers && t < this.frames.length; t++) this.processFrame(t) }, processNextFrame: function () { for (var e = -1, t = 0; t < this.frames.length; t++) { const r = this.frames[t]; if (!r.done && !r.beingProcessed) { e = t; break } }e >= 0 && this.processFrame(e) }, generateGIF: function (e, t) { const r = []; const i = { loop: this.repeat }; const n = this.options; const o = n.interval; const a = n.frameDuration; const s = n.images; const d = !!s.length; const c = n.gifHeight; const u = n.gifWidth; const m = new l(r, u, c, i); const g = this.onRenderProgressCallback; const f = d ? 100 * o : 0; let h = void 0; let p = void 0; this.generatingGIF = !0, w.each(e, function (t, r) { const i = r.palette; g(0.75 + 0.25 * r.position * 1 / e.length); for (let n = 0; a > n; n++)m.addFrame(0, 0, u, c, r.pixels, { palette: i, delay: f }) }), m.end(), g(1), this.frames = [], this.generatingGIF = !1, w.isFunction(t) && (h = this.bufferToString(r), p = 'data:image/gif;base64,' + w.btoa(h), t(p)) }, setRepeat: function (e) { this.repeat = e }, addFrame: function (e, t, r) { t = w.isObject(t) ? t : {}; const i = this; const n = i.ctx; const o = i.options; const a = o.gifWidth; const s = o.gifHeight; const d = w.getFontSize(t); const c = t; const l = c.filter; const u = c.fontColor; const m = c.fontFamily; const g = c.fontWeight; const f = (c.gifHeight, c.gifWidth, c.text); const h = c.textAlign; const p = c.textBaseline; const v = c.waterMark; const b = c.waterMarkHeight; const y = c.waterMarkWidth; const C = c.waterMarkXCoordinate; const k = c.waterMarkYCoordinate; const S = t.textXCoordinate ? t.textXCoordinate : h === 'left' ? 1 : h === 'right' ? a : a / 2; const x = t.textYCoordinate ? t.textYCoordinate : p === 'top' ? 1 : p === 'center' ? s / 2 : s; const F = g + ' ' + d + ' ' + m; const W = r && t.showFrameText ? r : f; let O = void 0; try { n.filter = l, n.drawImage(e, 0, 0, a, s), W && (n.font = F, n.fillStyle = u, n.textAlign = h, n.textBaseline = p, n.fillText(W, S, x)), v && n.drawImage(v, C, k, y, b), O = n.getImageData(0, 0, a, s), i.addFrameImageData(O) } catch (E) { return '' + E } }, addFrameImageData: function () { const e = arguments.length > 0 && arguments[0] !== i ? arguments[0] : {}; const t = this.frames; const r = e.data; this.frames.push({ data: r, width: e.width, height: e.height, palette: null, dithering: null, done: !1, beingProcessed: !1, position: t.length }) }, onRenderProgress: function (e) { this.onRenderProgressCallback = e }, isRendering: function () { return this.generatingGIF }, getBase64GIF: function (e) { const t = this; const r = function (r) { t.destroyWorkers(), w.requestTimeout(function () { e(r) }, 0) }; t.startRendering(r) }, destroyWorkers: function () { if (!this.workerError) { const e = this.workers; w.each(e, function (e, t) { const r = t.worker; const i = t.objectUrl; r.terminate(), w.URL.revokeObjectURL(i) }) } } }; const E = function () {}; var M = { getGIF: function () { const e = arguments.length > 0 && arguments[0] !== i ? arguments[0] : {}; let r = arguments[1]; r = w.isFunction(r) ? r : E; const n = t.createElement('canvas'); let o = void 0; const a = e.images; const s = !!a.length; const d = e.cameraStream; const c = e.crop; const l = e.filter; const u = e.fontColor; const m = e.fontFamily; const g = e.fontWeight; const f = e.keepCameraOn; const h = (e.numWorkers, e.progressCallback); const p = e.saveRenderingContexts; const v = e.savedRenderingContexts; const b = e.text; const y = e.textAlign; const C = e.textBaseline; const k = e.videoElement; const S = e.videoHeight; const x = e.videoWidth; const F = e.webcamVideoElement; const W = e.waterMark; const M = e.waterMarkHeight; const A = e.waterMarkWidth; const U = e.waterMarkXCoordinate; const R = e.waterMarkYCoordinate; const T = Number(e.gifWidth); const I = Number(e.gifHeight); let j = Number(e.interval); const V = (Number(e.sampleInterval), s ? 0 : 1e3 * j); const H = []; let z = v.length ? v.length : e.numFrames; let L = z; const B = new O(e); const P = w.getFontSize(e); const G = e.textXCoordinate ? e.textXCoordinate : y === 'left' ? 1 : y === 'right' ? T : T / 2; const D = e.textYCoordinate ? e.textYCoordinate : C === 'top' ? 1 : C === 'center' ? I / 2 : I; const N = g + ' ' + P + ' ' + m; let q = c ? Math.floor(c.scaledWidth / 2) : 0; let X = c ? x - c.scaledWidth : 0; let Y = c ? Math.floor(c.scaledHeight / 2) : 0; let Q = c ? S - c.scaledHeight : 0; const _ = function K () { function e () { try { X > x && (X = x), Q > S && (Q = S), q < 0 && (q = 0), Y < 0 && (Y = 0), o.filter = l, o.drawImage(k, q, Y, X, Q, 0, 0, T, I), t() } catch (r) { if (r.name !== 'NS_ERROR_NOT_AVAILABLE') throw r; w.requestTimeout(e, 100) } } function t () { let e = void 0; p && H.push(o.getImageData(0, 0, T, I)), W && o.drawImage(W, U, R, A, M), b && (o.font = N, o.fillStyle = u, o.textAlign = y, o.textBaseline = C, o.fillText(b, G, D)), e = o.getImageData(0, 0, T, I), B.addFrameImageData(e), L = i, h((z - L) / z), i > 0 && w.requestTimeout(K, V), L || B.getBase64GIF(function (e) { r({ error: !1, errorCode: '', errorMsg: '', image: e, cameraStream: d, videoElement: k, webcamVideoElement: F, savedRenderingContexts: H, keepCameraOn: f }) }) } var i = L - 1; v.length ? (o.putImageData(v[z - L], 0, 0), t()) : e() }; z = z !== i ? z : 10, j = j !== i ? j : 0.1, n.width = T, n.height = I, o = n.getContext('2d'), (function J () { return v.length || k.currentTime !== 0 ? (_(), void 0) : (w.requestTimeout(J, 100), void 0) }()) }, getCropDimensions: function () { const e = arguments.length > 0 && arguments[0] !== i ? arguments[0] : {}; const t = e.videoWidth; const r = e.videoHeight; const n = e.gifWidth; const o = e.gifHeight; const a = { width: 0, height: 0, scaledWidth: 0, scaledHeight: 0 }; return t > r ? (a.width = Math.round(t * (o / r)) - n, a.scaledWidth = Math.round(a.width * (r / o))) : (a.height = Math.round(r * (n / t)) - o, a.scaledHeight = Math.round(a.height * (t / n))), a } }; var A = { loadedData: !1, defaultVideoDimensions: { width: 640, height: 480 }, findVideoSize: function T (e) { T.attempts = T.attempts || 0; const t = e.cameraStream; const r = e.completedCallback; const i = e.videoElement; i && (i.videoWidth > 0 && i.videoHeight > 0 ? (i.removeEventListener('loadeddata', A.findVideoSize), r({ videoElement: i, cameraStream: t, videoWidth: i.videoWidth, videoHeight: i.videoHeight })) : T.attempts < 10 ? (T.attempts += 1, w.requestTimeout(function () { A.findVideoSize(e) }, 400)) : r({ videoElement: i, cameraStream: t, videoWidth: A.defaultVideoDimensions.width, videoHeight: A.defaultVideoDimensions.height })) }, onStreamingTimeout: function (e) { w.isFunction(e) && e({ error: !0, errorCode: 'getUserMedia', errorMsg: 'There was an issue with the getUserMedia API - Timed out while trying to start streaming', image: null, cameraStream: {} }) }, stream: function (e) { const t = w.isArray(e.existingVideo) ? e.existingVideo[0] : e.existingVideo; const r = e.cameraStream; const i = e.completedCallback; const n = e.streamedCallback; const o = e.videoElement; if (w.isFunction(n) && n(), t) { if (w.isString(t))o.src = t, o.innerHTML = '<source src="' + t + '" type="video/' + w.getExtension(t) + '" />'; else if (t instanceof Blob) { try { o.src = w.URL.createObjectURL(t) } catch (a) {}o.innerHTML = '<source src="' + t + '" type="' + t.type + '" />' } } else if (o.mozSrcObject)o.mozSrcObject = r; else if (w.URL) try { o.srcObject = r, o.src = w.URL.createObjectURL(r) } catch (a) { o.srcObject = r }o.play(), w.requestTimeout(function s () { s.count = s.count || 0, A.loadedData === !0 ? (A.findVideoSize({ videoElement: o, cameraStream: r, completedCallback: i }), A.loadedData = !1) : (s.count += 1, s.count > 10 ? A.findVideoSize({ videoElement: o, cameraStream: r, completedCallback: i }) : s()) }, 0) }, startStreaming: function (e) { const r = w.isFunction(e.error) ? e.error : w.noop; const i = w.isFunction(e.streamed) ? e.streamed : w.noop; const n = w.isFunction(e.completed) ? e.completed : w.noop; const o = e.crossOrigin; const a = e.existingVideo; const s = e.lastCameraStream; const d = e.options; const c = e.webcamVideoElement; const l = w.isElement(a) ? a : c || t.createElement('video'); o && (l.crossOrigin = d.crossOrigin), l.autoplay = !0, l.loop = !0, l.muted = !0, l.addEventListener('loadeddata', function () { A.loadedData = !0, d.offset && (l.currentTime = d.offset) }), a ? A.stream({ videoElement: l, existingVideo: a, completedCallback: n }) : s ? A.stream({ videoElement: l, cameraStream: s, streamedCallback: i, completedCallback: n }) : w.getUserMedia({ video: !0 }, function (e) { A.stream({ videoElement: l, cameraStream: e, streamedCallback: i, completedCallback: n }) }, r) }, startVideoStreaming: function (e) { const t = arguments.length > 1 && arguments[1] !== i ? arguments[1] : {}; const r = t.timeout !== i ? t.timeout : 0; const n = t.callback; const o = t.webcamVideoElement; let a = void 0; r > 0 && (a = w.requestTimeout(function () { A.onStreamingTimeout(n) }, 1e4)), A.startStreaming({ error: function () { n({ error: !0, errorCode: 'getUserMedia', errorMsg: 'There was an issue with the getUserMedia API - the user probably denied permission', image: null, cameraStream: {} }) }, streamed: function () { clearTimeout(a) }, completed: function () { const t = arguments.length > 0 && arguments[0] !== i ? arguments[0] : {}; const r = t.cameraStream; const n = t.videoElement; const o = t.videoHeight; const a = t.videoWidth; e({ cameraStream: r, videoElement: n, videoHeight: o, videoWidth: a }) }, lastCameraStream: t.lastCameraStream, webcamVideoElement: o, crossOrigin: t.crossOrigin, options: t }) }, stopVideoStreaming: function (e) { e = w.isObject(e) ? e : {}; const t = e; const r = t.keepCameraOn; const i = t.videoElement; const n = t.webcamVideoElement; const o = e.cameraStream || {}; const a = o.getTracks ? o.getTracks() || [] : []; const s = !!a.length; const d = a[0]; !r && s && w.isFunction(d.stop) && d.stop(), w.isElement(i) && !n && (i.pause(), w.isFunction(w.URL.revokeObjectURL) && !w.webWorkerError && i.src && w.URL.revokeObjectURL(i.src), w.removeElement(i)) } }; const U = { utils: y, error: k, defaultOptions: F, createGIF: v, takeSnapShot: b, stopVideoStreaming: g, isSupported: n, isWebCamGIFSupported: o, isExistingVideoGIFSupported: s, isExistingImagesGIFSupported: a, VERSION: '0.4.5' }; typeof define === 'function' && define.amd ? define([], function () { return U }) : typeof exports !== 'undefined' ? module.exports = U : e.gifshot = U }(typeof window !== 'undefined' ? window : {}, typeof document !== 'undefined' ? document : { createElement: function () {} }, typeof window !== 'undefined' ? window.navigator : {}))
